# --- Builder: Python deps ---
ARG BUILDER_BASE=python:3.13-slim
FROM ${BUILDER_BASE} AS builder

WORKDIR /app
ENV DEBIAN_FRONTEND=noninteractive

# Install build deps needed for building Python wheels (keep runtime-only packages out)
RUN apt-get update \
    && apt-get install -y --no-install-recommends \
        build-essential \
        gcc \
        make \
        pkg-config \
        libffi-dev \
        libssl-dev \
        libxml2-dev \
        libxslt1-dev \
        libjpeg-dev \
        zlib1g-dev \
        libcairo2 \
        libpango-1.0-0 \
        libpangocairo-1.0-0 \
    && apt-get clean \
    && rm -rf /var/lib/apt/lists/*

COPY requirements.txt .
# Build a wheelhouse in the builder stage so the runtime image can install
# binary wheels without needing to compile source packages or copy a full venv.
RUN python -m pip install --upgrade pip setuptools wheel \
    && python -m pip wheel --wheel-dir /wheels -r requirements.txt

# --- Runtime: backend only (uses prebuilt frontend static files provided by CI) ---
FROM python:3.13-slim

WORKDIR /app
ENV DEBIAN_FRONTEND=noninteractive

RUN apt-get update \
    && apt-get install -y --no-install-recommends \
        libcairo2 \
        libpango-1.0-0 \
        libpangocairo-1.0-0 \
        libgdk-pixbuf-xlib-2.0-0 \
        shared-mime-info \
        libfontconfig1 \
        fonts-dejavu-core \
    && apt-get clean \
    && rm -rf /var/lib/apt/lists/*

# Copy built wheels from the builder and install them into a fresh venv
COPY --from=builder /wheels /wheels
RUN python -m venv /venv \
    && /venv/bin/python -m pip install --upgrade pip setuptools wheel \
    && /venv/bin/pip install --no-index --find-links /wheels -r requirements.txt \
    && rm -rf /wheels
ENV PATH="/venv/bin:$PATH"

# Copy only the runtime application files we need to keep the image small.
# We rely on the prebuilt virtualenv copied from the builder stage, so we only
# need the backend package, wsgi entrypoint, built static assets and templates.
# This avoids sending the entire repo (node_modules, .git, etc.) into the image.
COPY backend /app/backend
COPY wsgi.py /app/wsgi.py

# The frontend `static/` directory will be produced by the separate frontend
# build job and downloaded into the repo by the workflow. Ensure it is present
# at `backend/static` in the repo; copy into the image so Flask can serve the
# built assets.
COPY backend/static ./backend/static
# Public assets from frontend (if any) can be mirrored into backend/static
COPY frontend/public ./backend/static/public

# Copy generated templates (if produced by the frontend build step)
COPY backend/templates ./backend/templates

# Cleanup bytecode
RUN rm -rf /venv/lib/python*/site-packages/__pycache__ \
    && find . -type d -name '__pycache__' -exec rm -r {} +

ENV FLASK_ENV=production
ENV FLASK_DEBUG=0
EXPOSE 5000
# Run with gunicorn for production-grade WSGI serving
CMD ["gunicorn", "-w", "4", "-b", "0.0.0.0:5000", "wsgi:app"]
